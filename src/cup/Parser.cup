package com.ufcg.compiladores;

import java.util.*;

import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.*;

import com.ufcg.compiladores.generation.*;

action code {:
:}

parser code {:
	@Override
	public int error_sync_size() {
		return 1;
	}

	@Override
	public void syntax_error(Symbol token) {
		ComplexSymbol complex = (ComplexSymbol) token;

		Log.focus(complex.xleft);
		Log.error("Illegal syntax");
	}
:};


terminal Boolean	BOOLEAN;
terminal Integer	INTEGER;
terminal String		STRING, IDENTIFIER;

terminal PROGRAM, BEGIN, END, VAR, FUNCTION, PROCEDURE, REPEAT, UNTIL;
terminal EQ, NE, GT, LT, GE, LE, ADD, SUB, MUL, DIV, MOD, ASSIGN;
terminal ARRAY, OF, RANGE;
terminal LEFT_PARENTHESIS, RIGHT_PARENTHESIS, LEFT_BRACKET, RIGHT_BRACKET;
terminal COMMA, COLON, SEMICOLON, DOT;

non terminal Root			root;
non terminal Block			block;
non terminal List<Decl>		declarations, variables;
non terminal Decl			declaration, procedure, function, variable;
non terminal List<Stmt>		statements, body;
non terminal Stmt			statement, repeat, assign, call_stmt;
non terminal List<Expr>		expressions, opt_arguments, arguments;
non terminal Expr			expression, exp0, exp1, exp2, exp3, exp4, literal, opt_init, call_expr;

non terminal Type			type;
non terminal List<Type>		opt_params, params, param;
non terminal List<Token>	identifiers;

non terminal subscript;
non terminal array;

start with root;

root			::= PROGRAM IDENTIFIER SEMICOLON {: Scope.push(); :} block:b DOT {: Scope.pop(); RESULT = new Root(b); :};

block			::= declarations:d body:b {: RESULT = new Block(d, b); :};

body			::= BEGIN statements:s END {: RESULT = s; :}
				|	BEGIN statements error END;

declarations	::= declarations:l declaration:d {: l.add(d); RESULT = l; :}
				|	/* empty */ {: RESULT = new ArrayList<>(); :};

declaration		::= VAR variables:v {: RESULT = new Decl.Compose(v); :}
				|	function:f SEMICOLON {: RESULT = f; :}
				|	procedure:p SEMICOLON {: RESULT = p; :};

variables		::= variables:l variable:v SEMICOLON {: l.add(v); RESULT = l; :}
				|	variable:v SEMICOLON {: RESULT = new ArrayList<>(); RESULT.add(v); :};

variable		::= identifiers:l COMMA IDENTIFIER:id COLON type:t {: for(Token token : l) { Log.focus(token.loc); Scope.add(token.name, t, Ref.var); } Log.focus(idxleft); Scope.add(id, t, Ref.var); RESULT = Decl.noop; :}
				|	IDENTIFIER:id COLON type:t {: Log.focus(idxleft); Scope.add(id, t, Ref.var); :} opt_init:e {: RESULT = new Decl.Init(Scope.get(id), e); :};

type			::= IDENTIFIER:id {: Log.focus(idxleft); RESULT = Type.translate(id); :}
				|	ARRAY OF type
				|	ARRAY LEFT_BRACKET subscript RIGHT_BRACKET OF type;

subscript		::= IDENTIFIER
				|	expression RANGE expression; // express√µes devem ser constantes

opt_init		::= EQ expression:e {: Log.focus(exleft); if (e.dynamic) Log.error("Expected a constant expression"); RESULT = e; :}
				|	/* empty */;

procedure		::= PROCEDURE IDENTIFIER:id {: Log.focus(idxleft); Scope.add('.' + id, null, Ref.lab); Scope.push(); Ref.var.save(); :} opt_params:p {: Scope.get('.' + id).t = new Type.Call(p, Type.Void); :} SEMICOLON block:b {: RESULT = new Decl.Procedure(id, p, b); Scope.pop(); :}
				|	PROCEDURE error END;

function		::= FUNCTION IDENTIFIER:id {: Log.focus(idxleft); Scope.add('.' + id, null, Ref.lab); Scope.push(); Ref.var.save(); :} opt_params:p COLON IDENTIFIER:t SEMICOLON {: Scope.Instance i = Scope.get('.' + id); Log.focus(txleft); Type type = Type.translate(t); i.t = new Type.Call(p, type); Log.focus(idxleft); Scope.add(id, type, Ref.var); :} block:b {: RESULT = new Decl.Function(id, p, b); Scope.pop(); :}
				|	FUNCTION error END;

opt_params		::= LEFT_PARENTHESIS params:p RIGHT_PARENTHESIS {: RESULT = p; :}
				|	LEFT_PARENTHESIS RIGHT_PARENTHESIS {: RESULT = new ArrayList<>(); :}
				|	/* empty */ {: RESULT = new ArrayList<>(); :};

params			::= params:l SEMICOLON param:p {: RESULT = l; RESULT.addAll(p); :}
				|	param:p {: RESULT = p; :};

param			::= identifiers:l COLON IDENTIFIER:id {: Log.focus(idxleft); Type t = Type.translate(id); RESULT = new ArrayList<>(); for(Token token : l) { Scope.overwrite(token.name, t, Ref.var); RESULT.add(t); } :}
				|	VAR identifiers COLON IDENTIFIER;

identifiers		::= identifiers:l COMMA IDENTIFIER:id {: Token token = new Token(id, idxleft); l.add(token); RESULT = l; :}
				|	IDENTIFIER:id {: RESULT = new ArrayList<>(); Token token = new Token(id, idxleft); RESULT.add(token); :};

array			::= IDENTIFIER LEFT_BRACKET expressions RIGHT_BRACKET;

literal			::= BOOLEAN:b {: RESULT = new Expr.Literal(Type.Boolean, b? 1 : 0); :}
				|	INTEGER:i {: RESULT = new Expr.Literal(Type.Integer, i); :}
				|	STRING;

statements		::= statements:l statement:s SEMICOLON {: l.add(s); RESULT = l; :}
				|	/* empty */ {: RESULT = new ArrayList<>(); :};

statement		::= assign:a {: RESULT = a; :}
				|	repeat:r {: RESULT = r; :}
				|	call_stmt:c {: RESULT = c; :}
				|	error;

call_stmt		::= IDENTIFIER:id LEFT_PARENTHESIS opt_arguments:a RIGHT_PARENTHESIS {: Log.focus(idxleft); RESULT = new Stmt.Call(Scope.get('.' + id), a); :};

call_expr		::= IDENTIFIER:id LEFT_PARENTHESIS opt_arguments:a RIGHT_PARENTHESIS {: Log.focus(idxleft); RESULT = new Expr.Call(Scope.get('.' + id), a); :};

opt_arguments	::= arguments:l {: RESULT = l; :}
				|	/* empty */ {: RESULT = new ArrayList<>(); :};

arguments		::= arguments:l COMMA expression:e {: l.add(e); RESULT = l; :}
				|	expression:e {: RESULT = new ArrayList<>(); RESULT.add(e); :};

assign			::= IDENTIFIER:id ASSIGN expression:e {: Log.focus(idxleft); RESULT = new Stmt.Assign(Scope.get(id), e); :}
				|	array ASSIGN expression;

expressions		::= expressions COMMA expression
				|	expression;

expression		::= exp0:e {: RESULT = e; :};

exp0			::= exp0:e1 EQ:op exp1:e2 {: Log.focus(opxleft); RESULT = new Expr.Relop(e1, "je" , e2); :}
				|	exp0:e1 NE:op exp1:e2 {: Log.focus(opxleft); RESULT = new Expr.Relop(e1, "jne", e2); :}
				|	exp0:e1 GT:op exp1:e2 {: Log.focus(opxleft); RESULT = new Expr.Relop(e1, "jg" , e2); :}
				|	exp0:e1 LT:op exp1:e2 {: Log.focus(opxleft); RESULT = new Expr.Relop(e1, "jl" , e2); :}
				|	exp0:e1 GE:op exp1:e2 {: Log.focus(opxleft); RESULT = new Expr.Relop(e1, "jge", e2); :}
				|	exp0:e1 LE:op exp1:e2 {: Log.focus(opxleft); RESULT = new Expr.Relop(e1, "jle", e2); :}
				|	exp1:e {: RESULT = e; :};
	
exp1			::= exp1:e1 ADD:op exp2:e2 {: Log.focus(opxleft); RESULT = new Expr.Binop(e1, "add", e2); :}
				|	exp1:e1 SUB:op exp2:e2 {: Log.focus(opxleft); RESULT = new Expr.Binop(e1, "sub", e2); :}
				|	exp2:e {: RESULT = e; :};
	
exp2			::= exp2:e1 MUL:op exp3:e2 {: Log.focus(opxleft); RESULT = new Expr.Binop(e1, "mul", e2); :}
				|	exp2:e1 DIV:op exp3:e2 {: Log.focus(opxleft); RESULT = new Expr.Binop(e1, "div", e2); :}
				|	exp2:e1 MOD:op exp3:e2 {: Log.focus(opxleft); RESULT = new Expr.Binop(e1, "mod", e2); :}
				|	exp3:e {: RESULT = e; :};
	
exp3			::= ADD:op exp3:e {: Log.focus(opxleft); RESULT = e; :}
				|	SUB:op exp3:e {: Log.focus(opxleft); RESULT = new Expr.Unop("neg", e); :}
				|	exp4:e {: RESULT = e; :};
	
exp4			::= IDENTIFIER:id {: Log.focus(idxleft); RESULT = new Expr.Identifier(Scope.get(id)); :}
				|	LEFT_PARENTHESIS exp0:e RIGHT_PARENTHESIS {: RESULT = e; :}
				|	literal:l {: RESULT = l; :}
				|	call_expr:c {: RESULT = c; :}
				|	array;

repeat			::= REPEAT statements:s UNTIL expression:e {: Log.focus(exleft); RESULT = new Stmt.Repeat(s, e); :};
	