package com.ufcg.compiladores;

import java_cup.runtime.*;
import com.ufcg.compiladores.symbols.Symbol;
import com.ufcg.compiladores.symbols.SymbolTable;
import com.ufcg.compiladores.type.LiteralType;
import com.ufcg.compiladores.type.FunctionType;
import java.util.*;

parser code {:

	//private SymbolTable st = new SymbolTable();

	public LiteralType sintArType(Object type1, Object type2) {
		LiteralType s1 = (LiteralType)type1;
		LiteralType s2 = (LiteralType)type2;

		if (s1.getName() == "integer" && s2.getName() == "integer") {
			return s1;
		}
		// add this error to error counter and add line
		System.err.println("Syntar Error: expected integer type.");
		Main.errors.increase();
		return null;
	}

	public void sem_error(String lexeme, String message) {
		System.err.println("Error in line "+ Main.lexer.current_line() + " : Semantic error");
      	System.err.println("==> " + message + ": "+ lexeme + "\n");
		Main.errors.increase();
  	}
  	
  	public void sem_error(String message) {
		System.err.println("Error "+ Main.lexer.current_lexeme() + " : Semantic error");
      	System.err.println("==> " + message +"\n");
		Main.errors.increase();
  	}


	public void checkTypesAttr(Object id, Object type) {
		if (type != null) {
			String idAux = (String)id;
			LiteralType t = (LiteralType)type;

			LiteralType idType = SymbolTable.getSymbol(idAux);

			if (idType == null) {
				sem_error(idAux, "Identifier not found");
				Main.errors.increase();
			}
			else if (!idType.getName().equals(t.getName())) {
				sem_error("Incompatible types");
				Main.errors.increase();
			}
		}
	}

	public void mapTypes(Object il, Object id, Object t) {
		List<String> idList = ((ArrayList<String>)il);
		
		if (id != null)
			idList.add((String)id);

		for (String curr_id : idList) {
			if (!SymbolTable.addSymbol((String)curr_id, (LiteralType)t)) {
				sem_error((String)curr_id, "duplicate name");
			}
		}
	}

:};

init with {:
	SymbolTable.start();
:};

terminal PROGRAM, BEGIN, END, VAR, FUNCTION, PROCEDURE;
terminal REPEAT, UNTIL;
terminal INT_TYPE, BOOLEAN_TYPE, STR_TYPE;
terminal EQ, NE, GT, LT, GE, LE, ADD, SUB, MUL, DIV, MOD, ASSIGN;
terminal BOOLEAN, INTEGER, STRING, ARRAY, OF, RANGE;
terminal LEFT_PARENTHESIS, RIGHT_PARENTHESIS, LEFT_BRACKET, RIGHT_BRACKET;
terminal COMMA, COLON, SEMICOLON, DOT;
terminal IDENTIFIER;

non terminal root, program, body;
non terminal declarations, declaration, statements, statement;
non terminal variables, variable, type, type_id, subscript, identifiers, literal, opt_init;
non terminal function, procedure, opt_params, params, param;
non terminal repeat, attribuition, array, call, opt_arguments, arguments;
non terminal expressions, expression, exp0, exp1, exp2, exp3, exp4;

start with root;

root			::= program declarations body DOT;
program			::= PROGRAM IDENTIFIER SEMICOLON;
body			::= BEGIN statements END; 

declarations	::= declarations declaration
				|	/* empty */;

declaration		::= VAR variables
				|	function SEMICOLON {: SymbolTable.pop(); :}
				|	procedure SEMICOLON;

variables		::= variables variable SEMICOLON
				|	variable SEMICOLON;

variable		::= IDENTIFIER:id COMMA identifiers:il COLON type:t {:  mapTypes(il, id, t); :}
				|	IDENTIFIER:id COLON type:t opt_init {: 	if (!SymbolTable.addSymbol((String)id, (LiteralType)t)) {
																parser.sem_error((String)id, "duplicate name");
															} 
														:};

type			::= type_id:t {: RESULT = t; :}
				|	ARRAY OF type
				|	ARRAY LEFT_BRACKET subscript RIGHT_BRACKET OF type;

type_id			::= INT_TYPE 	{: RESULT = new LiteralType("integer"); :}
				| BOOLEAN_TYPE	{: RESULT = new LiteralType("boolean"); :}
				| STR_TYPE		{: RESULT = new LiteralType("string");  :};	

subscript		::= IDENTIFIER
				|	expression RANGE expression; // expressões devem ser constantes

opt_init		::= EQ expression // expressões devem ser constantes
				|	/* empty */;

procedure		::= PROCEDURE IDENTIFIER opt_params SEMICOLON declarations BEGIN statements END;

function		::= FUNCTION IDENTIFIER:id opt_params:paramsList COLON type:t {: 
							String functionId = (String)id;
							
							if (!SymbolTable.addSymbol(functionId, new FunctionType((LiteralType)t))) {
								parser.sem_error(functionId, "duplicate name");
							} else {
								if (paramsList != null) {
									FunctionType type = (FunctionType)SymbolTable.getSymbol(functionId);
									type.addParams((ArrayList<LiteralType>) paramsList);
								}
								SymbolTable.push();
							}	
					:} SEMICOLON declarations BEGIN statements END;


opt_params		::= LEFT_PARENTHESIS params:paramsList RIGHT_PARENTHESIS {: RESULT = paramsList; :}
				|	LEFT_PARENTHESIS RIGHT_PARENTHESIS
				|	/* empty */;

params			::= params:paramsList SEMICOLON param:t {: ((ArrayList<LiteralType>)paramsList).add((LiteralType)t); RESULT = paramsList; :}
				|	param:t {: List<LiteralType> paramsList = new ArrayList<LiteralType>();
   					 					paramsList.add((LiteralType)t);
   					 					RESULT = paramsList;  :};

param			::= identifiers:il COLON type:t {: mapTypes(il, null, t); RESULT = t; :}
				|	VAR identifiers:il COLON type:t {: mapTypes(il, null, t); RESULT = t; :};

identifiers		::= identifiers:il COMMA IDENTIFIER:id {: ((ArrayList<String>)il).add(((String)id).toLowerCase()); RESULT = il; :}
				|	IDENTIFIER:id 	{:  List<String> il = new ArrayList<String>();
   					 					il.add(((String)id).toLowerCase());
   					 					RESULT = il; 
									:};

array			::= IDENTIFIER LEFT_BRACKET expressions RIGHT_BRACKET;

literal			::= BOOLEAN {: LiteralType t = new LiteralType("boolean"); RESULT = t; :}
				|	INTEGER {: LiteralType t = new LiteralType("integer"); RESULT = t; :}
				|	STRING 	{: LiteralType t = new LiteralType("string"); RESULT = t; :};

statements		::= statements statement SEMICOLON
				|	/* empty */;

statement		::= attribuition
				|	call
				|	repeat;

call			::= IDENTIFIER LEFT_PARENTHESIS opt_arguments RIGHT_PARENTHESIS;

opt_arguments	::= arguments
				|	/* empty */;

arguments		::= arguments COMMA expression
				|	expression;

attribuition	::= IDENTIFIER:id ASSIGN expression:t {: checkTypesAttr(id, t); :}
				|	array ASSIGN expression;

expressions		::= expressions COMMA expression
				|	expression;

expression		::= exp0:t {: RESULT = t; :};

exp0			::= exp0 EQ exp1 {: RESULT = new LiteralType("boolean"); :}
				|	exp0 NE exp1 {: RESULT = new LiteralType("boolean"); :}
				|	exp0 GT exp1 {: RESULT = new LiteralType("boolean"); :}
				|	exp0 LT exp1 {: RESULT = new LiteralType("boolean"); :}
				|	exp0 GE exp1 {: RESULT = new LiteralType("boolean"); :}
				|	exp0 LE exp1 {: RESULT = new LiteralType("boolean"); :}
				|	exp1:t  {: RESULT = t; :};
	
exp1			::= exp1:t1 ADD exp2:t2 {: RESULT = sintArType(t1, t2); :}
				|	exp1:t1 SUB exp2:t2 {: RESULT = sintArType(t1, t2); :}
				|	exp2:t {: RESULT = t; :};
	
exp2			::= exp2:t1 MUL exp3:t2 {: RESULT = sintArType(t1, t2); :}
				|	exp2:t1 DIV exp3:t2 {: RESULT = sintArType(t1, t2); :}
				|	exp2:t1 MOD exp3:t2 {: RESULT = sintArType(t1, t2); :}
				|	exp3:t {: RESULT = t; :};
	
exp3			::= ADD exp3:t {: RESULT = t; :}
				|	SUB exp3:t {: RESULT = t; :}
				|	exp4:t {: RESULT = t; :};
	
exp4			::= IDENTIFIER
				|	LEFT_PARENTHESIS exp0:t RIGHT_PARENTHESIS {: RESULT = t; :}
				|	literal:t {: RESULT = t; :}
				|	call:t {: RESULT = t; :}
				|	array:t {: RESULT = t; :};

repeat			::= REPEAT statements UNTIL expression;
	