package com.ufcg.compiladores;

import java.util.*;
import java_cup.runtime.*;
import com.ufcg.compiladores.generation.*;

action code {:
:}

parser code {:
	@Override
	public int error_sync_size() {
		return 1;
	}

	@Override
	public void syntax_error(Symbol cur_token) {
		ErrorCounter.increase();
		String output = String.format("(%d,%d) Error: Illegal syntax\n", cur_token.left+1, cur_token.right+1);
		report_error(output, null);
	}
:};


terminal PROGRAM, BEGIN, END, VAR, FUNCTION, PROCEDURE, REPEAT, UNTIL;
terminal EQ, NE, GT, LT, GE, LE, ADD, SUB, MUL, DIV, MOD, ASSIGN;
terminal ARRAY, OF, RANGE;
terminal LEFT_PARENTHESIS, RIGHT_PARENTHESIS, LEFT_BRACKET, RIGHT_BRACKET;
terminal COMMA, COLON, SEMICOLON, DOT;

terminal Boolean	BOOLEAN;
terminal Integer	INTEGER;
terminal String		STRING, IDENTIFIER;

non terminal Program		root;
non terminal List<Decl>		declarations;
non terminal Decl			declaration;
non terminal List<Stmt>		statements, body;
non terminal Stmt			statement, repeat, assign;
non terminal List<Expr>		expressions;
non terminal Expr			expression, exp0, exp1, exp2, exp3, exp4, literal;

non terminal program;
non terminal variables, variable, type, subscript, identifiers, opt_init;
non terminal function, procedure, opt_params, params, param;
non terminal array, call, opt_arguments, arguments;

start with root;

root			::= program declarations:d body:b DOT {: RESULT = new Program(d, b); :};

program			::= PROGRAM IDENTIFIER SEMICOLON;

body			::= BEGIN statements:s END {: RESULT = s; :}
				|	BEGIN statements error END;

declarations	::= declarations declaration
				|	/* empty */;

declaration		::= VAR variables
				|	function SEMICOLON
				|	procedure SEMICOLON
				|	error;

variables		::= variables variable SEMICOLON
				|	variable SEMICOLON;

variable		::= IDENTIFIER COMMA identifiers COLON type
				|	IDENTIFIER COLON type opt_init;

type			::= IDENTIFIER
				|	ARRAY OF type
				|	ARRAY LEFT_BRACKET subscript RIGHT_BRACKET OF type;

subscript		::= IDENTIFIER
				|	expression RANGE expression; // expressões devem ser constantes

opt_init		::= EQ expression // expressões devem ser constantes
				|	/* empty */;

procedure		::= PROCEDURE IDENTIFIER opt_params SEMICOLON declarations body
				|	PROCEDURE error END;

function		::= FUNCTION IDENTIFIER opt_params COLON IDENTIFIER SEMICOLON declarations body
				|	FUNCTION error END;

opt_params		::= LEFT_PARENTHESIS params RIGHT_PARENTHESIS
				|	LEFT_PARENTHESIS RIGHT_PARENTHESIS
				|	/* empty */;

params			::= params SEMICOLON param
				|	param;

param			::= identifiers COLON IDENTIFIER
				|	VAR identifiers COLON IDENTIFIER;

identifiers		::= identifiers COMMA IDENTIFIER
				|	IDENTIFIER;

array			::= IDENTIFIER LEFT_BRACKET expressions RIGHT_BRACKET;

literal			::= BOOLEAN:b {: RESULT = Expr.literal(b ? 1 : 0); :}
				|	INTEGER:i {: RESULT = Expr.literal(i); :}
				|	STRING;

statements		::= statements:l statement:s SEMICOLON {: l.add(s); RESULT = l; :}
				|	/* empty */ {: RESULT = new ArrayList<Stmt>(); :};

statement		::= assign:a {: RESULT = a; :}
				|	call
				|	repeat:r {: RESULT = r; :}
				|	error;

call			::= IDENTIFIER LEFT_PARENTHESIS opt_arguments RIGHT_PARENTHESIS;

opt_arguments	::= arguments
				|	/* empty */;

arguments		::= arguments COMMA expression
				|	expression;

assign			::= IDENTIFIER:id ASSIGN expression:e {: RESULT = Stmt.assign(id, e); :}
				|	array ASSIGN expression;

expressions		::= expressions COMMA expression
				|	expression;

expression		::= exp0:e {: RESULT = e; :};

exp0			::= exp0 EQ exp1
				|	exp0 NE exp1
				|	exp0 GT exp1
				|	exp0 LT exp1
				|	exp0 GE exp1
				|	exp0 LE exp1
				|	exp1:e {: RESULT = e; :};
	
exp1			::= exp1:e1 ADD exp2:e2 {: RESULT = Expr.binop(e1, "add", e2); :}
				|	exp1:e1 SUB exp2:e2 {: RESULT = Expr.binop(e1, "sub", e2); :}
				|	exp2:e {: RESULT = e; :};
	
exp2			::= exp2:e1 MUL exp3:e2 {: RESULT = Expr.binop(e1, "mul", e2); :}
				|	exp2:e1 DIV exp3:e2 {: RESULT = Expr.binop(e1, "div", e2); :}
				|	exp2:e1 MOD exp3:e2 {: RESULT = Expr.binop(e1, "mod", e2); :}
				|	exp3:e {: RESULT = e; :};
	
exp3			::= ADD exp3:e {: RESULT = e; :}
				|	SUB exp3:e {: RESULT = Expr.unop("neg", e); :}
				|	exp4:e {: RESULT = e; :};
	
exp4			::= IDENTIFIER
				|	LEFT_PARENTHESIS exp0:e RIGHT_PARENTHESIS {: RESULT = e; :}
				|	literal:l {: RESULT = l; :}
				|	call
				|	array;

repeat			::= REPEAT statements:s UNTIL expression:e {: RESULT = Stmt.repeat(s, e); :};
	